'use strict'

/**
 * Updates matching return logs or creates missing ones based on those determined by the import from NALD data
 * @module
 */

const db = require('../../../lib/connectors/db.js')
const ReturnCycleHelpers = require('./return-cycle-helpers.js')

/**
 * Updates matching return logs or creates missing ones based on those determined by the import from NALD data
 *
 * From 2018-10-31 WRLS took over from NALD as the place where all return submissions were entered. However, the return
 * log (the header record submissions are made against) is still generated in NALD, and changes to the return versions
 * that they are generated from will cause existing return logs to become VOID.
 *
 * Because of this the import service still needs to determine which return logs _should_ exist based on the current
 * return version and requirements data held against a licence each night.
 *
 * Having determined which return logs (rows) it think should exist, it passes them to this service to be imported into
 * WRLS. If a matching return log already exists, we just update some fields. Else, we create the new record.
 *
 * @param {object[]} rows - rows of return logs generated by the import
 * @param {object} [returnCycles=null] - all return cycles for the service, split by summer and winter (all-year). This
 * is expected to be provided by licence-data-import as part of the overnight job. We don't want to call it for each
 * licence being imported. But if called from the testing endpoint this will be null.
 */
async function go (rows, returnCycles = null) {
  if (!returnCycles) {
    returnCycles = await ReturnCycleHelpers.fetch()
  }

  _assignReturnCycles(rows, returnCycles)

  await _persistReturnLogs(rows)
}

function _assignReturnCycles (rows, returnCycles) {
  for (const row of rows) {
    const result = ReturnCycleHelpers.match(returnCycles, row)

    // We don't ever expect to hit this. We've worked to fix the legacy code generating return logs with duff return
    // periods. But you never know with NALD data or the legacy code!
    if (!result) {
      global.GlobalNotifier.omg('licence-returns-import: no return cycle match', { row })

      continue
    }

    row.return_cycle_id = result.return_cycle_id
  }
}

async function _persistReturnLogs (rows) {
  const query = `
      INSERT INTO "returns"."returns" (
        due_date,
        end_date,
        licence_ref,
        licence_type,
        metadata,
        received_date,
        regime,
        return_cycle_id,
        return_id,
        return_requirement,
        returns_frequency,
        sent_date,
        "source",
        start_date,
        status,
        created_at,
        updated_at
      )
      SELECT
        (data->>'due_date')::date AS due_date,
        (data->>'end_date')::date AS end_date,
        (data->>'licence_ref') AS licence_ref,
        (data->>'licence_type') AS licence_type,
        (data->>'metadata')::jsonb AS metadata,
        (data->>'received_date')::date AS received_date,
        (data->>'regime') AS regime,
        (data->>'return_cycle_id')::uuid AS return_cycle_id,
        (data->>'return_id') AS return_id,
        (data->>'return_requirement') AS return_requirement,
        CAST(data->>'returns_frequency' AS "returns".returns_period) AS returns_frequency,
        (data->>'sent_date')::date AS sent_date,
        (data->>'source') AS "source",
        (data->>'start_date')::date AS start_date,
        CAST(data->>'status' AS "returns".returns_status) AS status,
        now() AS created_at,
        now() AS updated_at
      FROM (
        SELECT json_array_elements($1) AS data
      ) tmp
      ON CONFLICT (return_id) DO UPDATE
      SET
        due_date = EXCLUDED.due_date,
        metadata = EXCLUDED.metadata,
        received_date = EXCLUDED.received_date,
        return_cycle_id = EXCLUDED.return_cycle_id,
        returns_frequency = EXCLUDED.returns_frequency,
        sent_date = EXCLUDED.sent_date,
        status = EXCLUDED.status,
        updated_at = EXCLUDED.updated_at;
    `
  const params = [JSON.stringify(rows)]

  await db.query(query, params)
}

module.exports = {
  go
}
