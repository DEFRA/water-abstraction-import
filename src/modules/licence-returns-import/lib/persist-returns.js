'use strict'

/**
 * Updates matching return logs or creates missing ones based on those determined by the import from NALD data
 * @module
 */

const helpers = require('@envage/water-abstraction-helpers')

const db = require('../../../lib/connectors/db.js')
const ReplicateReturns = require('./replicate-returns.js')
const ReturnCycleHelpers = require('./return-cycle-helpers.js')

/**
 * Updates matching return logs or creates missing ones based on those determined by the import from NALD data
 *
 * From 2018-10-31 WRLS took over from NALD as the place where all return submissions were entered. However, the return
 * log (the header record submissions are made against) is still generated in NALD, and changes to the return versions
 * that they are generated from will cause existing return logs to become VOID.
 *
 * Because of this the import service still needs to determine which return logs _should_ exist based on the current
 * return version and requirements data held against a licence each night.
 *
 * Having determined which return logs (rows) it think should exist, it passes them to this service to be imported into
 * WRLS. If a matching return log already exists, we just update some fields (it differs for some reason based on
 * whether it ends before or after the 2018 switch over date). Else, we create the new record.
 *
 * The next check is whether we should replicate the NALD submission data in WRLS. We only do this when there is no
 * submission in WRLS.
 *
 * For reference, we expect this to be the exception. All submissions are now done in WRLS so nothing should be added to
 * NALD. But in preparation for taking over returns management from NALD, we enabled this feature to ensure all the
 * historic NALD submission data, which to this point had been left in NALD, was imported into WRLS. Once that data is
 * imported, the only time we should replicate something is because someone didn't get the memo about where to enter
 * a submission!
 *
 * @param {object[]} rows - rows of return logs generated by the import
 * @param {boolean} oldLinesExist - whether the one-off extract of pre-2013 NALD return lines exists for use when
 * replicating NALD submission data
 * @param {object} [returnCycles=null] - all return cycles for the service, split by summer and winter (all-year). This
 * is expected to be provided by licence-data-import as part of the overnight job. We don't want to call it for each
 * licence being imported. But if called from the testing endpoint this will be null.
 */
async function go (rows, oldLinesExist, returnCycles = null) {
  if (!returnCycles) {
    returnCycles = await ReturnCycleHelpers.fetch()
  }

  for (const row of rows) {
    await _createOrUpdateReturn(row, oldLinesExist, returnCycles)
  }
}

async function _create (row) {
  const params = [
    row.due_date,
    row.end_date,
    row.licence_ref,
    row.licence_type,
    row.metadata,
    row.received_date,
    row.regime,
    row.return_cycle_id,
    row.return_id,
    row.return_requirement,
    row.returns_frequency,
    row.sent_date,
    row.source,
    row.start_date,
    row.status
  ]

  const query = `
    INSERT INTO "returns"."returns" (
      due_date,
      end_date,
      licence_ref,
      licence_type,
      metadata,
      received_date,
      regime,
      return_cycle_id,
      return_id,
      return_requirement,
      returns_frequency,
      sent_date,
      "source",
      start_date,
      status,
      created_at,
      updated_at
    )
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, now(), now());
  `

  await db.query(query, params)
}

async function _createOrUpdateReturn (row, oldLinesExist, returnCycles) {
  const returnDataExists = await _returnDataExists(row.return_id)
  const { return_cycle_id } = ReturnCycleHelpers.match(returnCycles, row)

  row.return_cycle_id = return_cycle_id

  // Conditional update
  if (returnDataExists.return_log_exists) {
    await _update(row)
  } else {
    await _create(row)
  }

  // NOTE: Until the change was made to replicate NALD submission data in WRLS, the import would just create the return
  // log record. Generally, those marked 'complete' would be dated pre 2028-10-31. We recently found out that the legacy
  // water-abstraction-service has logic to read the submission-data directly from NALD. Anything after 2018-10-31 was
  // directly entered into WRLS, as that is when it took over from NALD as the place to submit returns.
  //
  // Why do you need to know this? It is because irrespective of whether we have just created the return log for the
  // first time, or we are updating it for the thousandth (!) this might be the run where replicating return submission
  // data has been enabled, so we need to kick off the replication, as long as no existing data was found.
  if (!returnDataExists.return_submission_exists) {
    await ReplicateReturns.go(row, oldLinesExist)
  }
}

async function _returnDataExists (returnId) {
  const params = [returnId]
  const query = `
    SELECT
      (EXISTS (SELECT 1 FROM "returns"."returns" WHERE return_id=$1)::bool) AS return_log_exists,
      (EXISTS (SELECT 1 FROM "returns".versions WHERE return_id=$1)::bool) AS return_submission_exists
    ;
  `
  const [result] = await db.query(query, params)

  return result
}

async function _update (row) {
  const params = [
    row.due_date,
    row.metadata,
    row.received_date,
    row.return_cycle_id,
    row.returns_frequency,
    row.sent_date,
    row.status,
    row.return_id
  ]

  const query = `
    UPDATE "returns"."returns" SET
      due_date = $1,
      metadata = $2,
      received_date = $3,
      return_cycle_id = $4,
      returns_frequency = $5,
      sent_date = $6,
      status = $7,
      updated_at = now()
    WHERE return_id=$8;
  `

  await db.query(query, params)
}

module.exports = {
  go
}
